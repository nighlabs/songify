// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: song_requests.sql

package db

import (
	"context"
	"database/sql"
)

const approveSongRequest = `-- name: ApproveSongRequest :exec
UPDATE song_requests SET status = 'approved', processed_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) ApproveSongRequest(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, approveSongRequest, id)
	return err
}

const createSongRequest = `-- name: CreateSongRequest :one
INSERT INTO song_requests (session_id, spotify_track_id, track_name, artist_names, album_name, album_art_url, duration_ms, spotify_uri)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, session_id, spotify_track_id, track_name, artist_names, album_name, album_art_url, duration_ms, spotify_uri, status, requested_at, processed_at, rejection_reason
`

type CreateSongRequestParams struct {
	SessionID      string         `json:"session_id"`
	SpotifyTrackID string         `json:"spotify_track_id"`
	TrackName      string         `json:"track_name"`
	ArtistNames    string         `json:"artist_names"`
	AlbumName      string         `json:"album_name"`
	AlbumArtUrl    sql.NullString `json:"album_art_url"`
	DurationMs     int64          `json:"duration_ms"`
	SpotifyUri     string         `json:"spotify_uri"`
}

func (q *Queries) CreateSongRequest(ctx context.Context, arg CreateSongRequestParams) (SongRequest, error) {
	row := q.db.QueryRowContext(ctx, createSongRequest,
		arg.SessionID,
		arg.SpotifyTrackID,
		arg.TrackName,
		arg.ArtistNames,
		arg.AlbumName,
		arg.AlbumArtUrl,
		arg.DurationMs,
		arg.SpotifyUri,
	)
	var i SongRequest
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.SpotifyTrackID,
		&i.TrackName,
		&i.ArtistNames,
		&i.AlbumName,
		&i.AlbumArtUrl,
		&i.DurationMs,
		&i.SpotifyUri,
		&i.Status,
		&i.RequestedAt,
		&i.ProcessedAt,
		&i.RejectionReason,
	)
	return i, err
}

const deleteSongRequest = `-- name: DeleteSongRequest :exec
DELETE FROM song_requests WHERE id = ?
`

func (q *Queries) DeleteSongRequest(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSongRequest, id)
	return err
}

const getPendingSongRequests = `-- name: GetPendingSongRequests :many
SELECT id, session_id, spotify_track_id, track_name, artist_names, album_name, album_art_url, duration_ms, spotify_uri, status, requested_at, processed_at, rejection_reason FROM song_requests WHERE session_id = ? AND status = 'pending' ORDER BY requested_at ASC
`

func (q *Queries) GetPendingSongRequests(ctx context.Context, sessionID string) ([]SongRequest, error) {
	rows, err := q.db.QueryContext(ctx, getPendingSongRequests, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SongRequest
	for rows.Next() {
		var i SongRequest
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.SpotifyTrackID,
			&i.TrackName,
			&i.ArtistNames,
			&i.AlbumName,
			&i.AlbumArtUrl,
			&i.DurationMs,
			&i.SpotifyUri,
			&i.Status,
			&i.RequestedAt,
			&i.ProcessedAt,
			&i.RejectionReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSongRequestByID = `-- name: GetSongRequestByID :one
SELECT id, session_id, spotify_track_id, track_name, artist_names, album_name, album_art_url, duration_ms, spotify_uri, status, requested_at, processed_at, rejection_reason FROM song_requests WHERE id = ?
`

func (q *Queries) GetSongRequestByID(ctx context.Context, id int64) (SongRequest, error) {
	row := q.db.QueryRowContext(ctx, getSongRequestByID, id)
	var i SongRequest
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.SpotifyTrackID,
		&i.TrackName,
		&i.ArtistNames,
		&i.AlbumName,
		&i.AlbumArtUrl,
		&i.DurationMs,
		&i.SpotifyUri,
		&i.Status,
		&i.RequestedAt,
		&i.ProcessedAt,
		&i.RejectionReason,
	)
	return i, err
}

const getSongRequestsBySessionID = `-- name: GetSongRequestsBySessionID :many
SELECT id, session_id, spotify_track_id, track_name, artist_names, album_name, album_art_url, duration_ms, spotify_uri, status, requested_at, processed_at, rejection_reason FROM song_requests WHERE session_id = ? ORDER BY requested_at DESC
`

func (q *Queries) GetSongRequestsBySessionID(ctx context.Context, sessionID string) ([]SongRequest, error) {
	rows, err := q.db.QueryContext(ctx, getSongRequestsBySessionID, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SongRequest
	for rows.Next() {
		var i SongRequest
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.SpotifyTrackID,
			&i.TrackName,
			&i.ArtistNames,
			&i.AlbumName,
			&i.AlbumArtUrl,
			&i.DurationMs,
			&i.SpotifyUri,
			&i.Status,
			&i.RequestedAt,
			&i.ProcessedAt,
			&i.RejectionReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isDuplicateRequest = `-- name: IsDuplicateRequest :one
SELECT EXISTS(
    SELECT 1 FROM song_requests
    WHERE session_id = ? AND spotify_track_id = ? AND status != 'rejected'
) AS is_duplicate
`

type IsDuplicateRequestParams struct {
	SessionID      string `json:"session_id"`
	SpotifyTrackID string `json:"spotify_track_id"`
}

func (q *Queries) IsDuplicateRequest(ctx context.Context, arg IsDuplicateRequestParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isDuplicateRequest, arg.SessionID, arg.SpotifyTrackID)
	var is_duplicate int64
	err := row.Scan(&is_duplicate)
	return is_duplicate, err
}

const rejectSongRequest = `-- name: RejectSongRequest :exec
UPDATE song_requests SET status = 'rejected', processed_at = CURRENT_TIMESTAMP, rejection_reason = ? WHERE id = ?
`

type RejectSongRequestParams struct {
	RejectionReason sql.NullString `json:"rejection_reason"`
	ID              int64          `json:"id"`
}

func (q *Queries) RejectSongRequest(ctx context.Context, arg RejectSongRequestParams) error {
	_, err := q.db.ExecContext(ctx, rejectSongRequest, arg.RejectionReason, arg.ID)
	return err
}
